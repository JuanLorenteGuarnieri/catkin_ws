# Laboratory 3
Before starting **important**:
```bash
source devel/setup.bash
```
It is good practice to run at startup even if it is not used directly:
```bash
roscore
```

## Start

## Exercise 1
**You need to go to the parent directory of the package "p14_arob_lab4" and execute:**
`find . -type f -not -path '*/\.*' -exec sed -i 's/p14/p??/g' {} +`

**Build the package and run the launch file arob-p4-navigation-basic.launch file. Notice that the first line of this file sets the parameter `use_sim_time` to true. This is to make sure all nodes running in our system use the simulation time published in the `/clock` topic by Stage simulator.**

```bash
roslaunch  p14_arob_lab4 arob-p4-navigation-basic.launch
```

**In another terminal publish a message in the topic /move_base_simple/goal and see how the robot moves to the goal:**

```bash
`rostopic pub /move_base_simple/goal geometry_msgs/PoseStamped '{ header: { frame_id: "map" }, pose: { position: { x: -3, y: 0 }, orientation: { x: 0, y: 0, z: 0, w: 1 } } }'`
```

## Exercise 2

**Close everything and launch the file arob-p4-navigation-rviz.launch that includes an instance of rviz. Observe the value of the different topics sending different goals to the robot.**

```bash
rosrun rviz rviz
```

Open configuration in rviz: `p14_arob_lab4/config`

## Exercise 3

**Now you have all the tools to analyze how some parameters can affect robot navigation. In particular, modify the value of the following parameters in the launch and configuration files:**
**- Try different global and local planners (planner_selection.yaml)**

```yaml
base_local_planner: base_local_planner/TrajectoryPlannerROS
base_global_planner: carrot_planner/CarrotPlanner
```

- Number of particles in AMCL
`p14_arob_lab4/launch/arob-p4-navigation-basic.launch`
```xml
    <param name="min_particles"             value="500"/>
	<param name="max_particles"             value="2000"/>
```

- Add obstacles:
`p14_arob_lab4/world/simple.world`


- Use the dynamic obstacle to make it difficult for the robot!**
```

```

## Exercise 4

Para ver la lista de plugins

``` bash
rospack plugins --attrib=plugin nav_core
```
```
~/catkin_ws$ rospack plugins --attrib=plugin nav_core
dwa_local_planner /opt/ros/noetic/share/dwa_local_planner/blp_plugin.xml
base_local_planner /opt/ros/noetic/share/base_local_planner/blp_plugin.xml
global_planner /opt/ros/noetic/share/global_planner/bgp_plugin.xml
clear_costmap_recovery /opt/ros/noetic/share/clear_costmap_recovery/ccr_plugin.xml
carrot_planner /opt/ros/noetic/share/carrot_planner/bgp_plugin.xml
move_slow_and_clear /opt/ros/noetic/share/move_slow_and_clear/recovery_plugin.xml
rotate_recovery /opt/ros/noetic/share/rotate_recovery/rotate_plugin.xml
navfn /opt/ros/noetic/share/navfn/bgp_plugin.xml
p14_arob_lab4 /home/qassiel/catkin_ws/src/p14_arob_lab4/llc_local_planner_plugin.xml
```

## Exercise 5

**Complete functions computeVelocityCommands() and isGoalReached() in llc_local_planner.cpp file to implement your low level controller. Do not forget to include the parameter values for your low level controller, which are defined in llc_local_planner_params.yaml.**

Modified `p14_arob_lab4/src/llc_local_planner.cpp`

```c++
bool LLCLocalPlanner::computeVelocityCommands(geometry_msgs::Twist& cmd_vel){
	    //Compute the velocity command (v,w) for a differential-drive robot

		// std::cout << "ComputeVelocityCommands ..." << std::endl;

		if(!initialized_){
			ROS_ERROR("THe planner has not been initialized.");
			return false;
		}

		//Get robot and goal pose in the global frame of the local costmap
		geometry_msgs::PoseStamped robot_pose;
		costmap_ros_->getRobotPose(robot_pose);
		geometry_msgs::PoseStamped goal = global_plan_.back();

		//Read obstacle information from the costmap
		costmap_ = costmap_ros_->getCostmap();
		for (unsigned int i=0; i<costmap_->getSizeInCellsX()-1; i++){
			for (unsigned int j=0; j<costmap_->getSizeInCellsY()-1; j++){
				if (costmap_->getCost(i,j) == costmap_2d::LETHAL_OBSTACLE){
					double obs_wx, obs_wy;
					geometry_msgs::Pose obs_pose;					
					costmap_->mapToWorld(i, j, obs_pose.position.x, obs_pose.position.y); //mapToWorld returns coordinates in the global frame of the local costmap
					// std::cout << "Obs coordinates: " << obs_pose.position.x << ", " << obs_pose.position.y << std::endl;
					
					if (euclideanDistance(robot_pose.pose, obs_pose) < 1.5*robot_radius_){
						ROS_ERROR("Imminent collision");
						return false;
					}

				}
			}
		}
		
		//include here your code for the low level controller
		// Calculate polar coordinates (p, alpha, B)
		double dx = goal.pose.position.x - robot_pose.pose.position.x;
		double dy = goal.pose.position.y - robot_pose.pose.position.y;
		double rho = sqrt(dx * dx + dy * dy);
		double theta = tf::getYaw(robot_pose.pose.orientation); // tf
		double alpha = -theta + atan2(dy, dx);
		double beta = -theta - alpha;

		// Control gains (assumed values)
		double k_rho, k_alpha, k_beta;
		ros::param::get("llc_local_planner/k_rho", k_rho);
		ros::param::get("llc_local_planner/k_alpha", k_alpha);
		ros::param::get("llc_local_planner/k_beta", k_beta);

		// Set linear and angular velocities based on the control law
		cmd_vel.linear.x = k_rho * rho;
		cmd_vel.angular.z = k_alpha * alpha + k_beta * beta;

		return true;
	}
```

```c++
bool LLCLocalPlanner::isGoalReached(){
		//Check if the robot has reached the position and orientation of the goal

		// std::cout << "isGoalReached ..." << std::endl;

		if (! initialized_) {
			ROS_ERROR("This planner has not been initialized.");
			return false;
		}

		//Get robot and goal pose in the global frame of the local costmap
		geometry_msgs::PoseStamped robot_pose;
		costmap_ros_->getRobotPose(robot_pose);
		const geometry_msgs::PoseStamped goal = global_plan_.back();

		bool goalReached = false;

		//implement here the condition(s) to have reached the goal

		// Thresholds for distance and orientation
		double distance_tolerance = 0.1;  // Adjust as necessary
		double angle_tolerance = 0.1;  // Adjust as necessary (in radians)

		// Calculate the distance to the goal
		double dx = goal.pose.position.x - robot_pose.pose.position.x;
		double dy = goal.pose.position.y - robot_pose.pose.position.y;
		double rho = sqrt(dx * dx + dy * dy);

		// Calculate orientation difference
		double theta_robot = tf::getYaw(robot_pose.pose.orientation);
		double theta_goal = tf::getYaw(goal.pose.orientation);
		double orientation_diff = fabs(theta_goal - theta_robot);

		// Check if both position and orientation are within thresholds
		goalReached = (rho < distance_tolerance) && (orientation_diff < angle_tolerance);


		return goalReached;		
	}
```

## Exercise 6

**Launch file arob-p4-navigation-plugin.launch with llc_local_planner as the local planner (planner_selection.yaml), and send different goals to evaluate the robot behavior.**

```bash
roslaunch  p14_arob_lab4  arob-p4-navigation-plugin.launch
```

```yaml
base_local_planner: p14_llc_local_planner/LLCLocalPlanner
```


`p14_arob_lab4/config/move_base/costmaps/costmap_common_params.yaml`